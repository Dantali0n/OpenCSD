% this file is called up by thesis.tex
% content in this file will be fed into the main document

\chapter{Consideration} % top level followed by section, subsection

% Explain the considerations and state of affair in general overview and
% introduce the different sections of this chapter.

\section{Filesystem Limitations}

% In memory data structures to represent files are not regularly flushed to the
% drive.

% File information on drive is not reconstructed upon mounting the filesystem

% Garbage collection is not performed.

% Checkpoints, NAT and SIT blocks are currently not flushed to drive.

% Files can not be removed.

% Path inode map is always complete, no actual caching

% lookup can only return for data in path inode map, won't traverse inode lba
% map.

\section{Concurrency}

% Global lock on some filesystem operations

% Scheduling for uBPF VM instances, locking around uBPF, identifying the correct
% vm to associate to the system call (unique hash placed in a map, any incorrect
% hash terminates the kernel immediately)

\section{Design for Manufacter}

% The current prototype is only suitable for simulation. Several changes are
% necessary for real world applications. Firstly, addition to the NVMe command set
% in the form of a new NVMe namespace. Secondly, the ABI needs to be formalized
% and become a integral part of the specification. Third, existing drivers, such
% as SPDK or xNVME, must be updated to support this new namespace and commands.

% Describe how the design would change for a real world, practical
% implementation. Take the ICD loader diagram as base.

\begin{figure}
    \centering
	\includegraphics[width=1\textwidth]{resources/images/loader-pfs-arch-v3.png}
	\caption{Practical complete architecture for vendor agnostic CSxs with
        potential filesystem support.}
    % \includesvg[width=0.6\columnwidth]{resources/images/module-dependencies}
    \label{figure:practicalarchitecture}
\end{figure}

\section{Effective Event Kernels}

% Introduction + problem statement

% Prevent double move / copy and additional roundtrip latency for event based
% kernels by submitting multiple kernels, several by the filesystem and one by
% the user. (last kernel can be eliminated if other safety / verification systems
% present)

% 1. The first kernel performs the actual I/O operation the event kernel is
% going to run on. The return value of this kernel is the metadata about the
% written or read blocks.

% 2. The second kernel is the user submitted kernel, it performs any desired
% operation based on what was read or written.

% 3. The last kernel is also submitted by the filesystem it checks and
% consolidates the actions performed by the user submitted kernel. This step is
% necessary since the user submitted kernel could potentially modify the file
% size.

\section{Filesystem Agnostic Kernels}

% Use statfs to determine the type of filesystem, ICDs are related to a specific
% filesystem type. The CSx eBPF ABI should contain atleast one system call to
% retrieve the vendor filesystem context data for the current request (already
% part of prototype). The CSx FS API contains functions and datastructures to
% allow the kernel to transform this context data. The API is implemented by
% individual filesystems as shared library and made available throught the ICD.
% The CSx FS runtime uses a loader with mechanisms such as \textit{dlopen} to
% verify the contents of the provided library in accordance to the API.

% The basic format of the ICD can be extended such that it could support
% extensions to the base API as well as contain versioning. Typically, ICD files
% are human readable using a markup language such as YAML. This is same approach
% as the prominent video graphics API Vulkan.

\begin{figure}
    \centering
	\includegraphics[width=0.7\textwidth]{resources/images/csx-fs-agnostic.png}
	\caption{Extended architecture to support filesystem agnostic CSx kernels.}
    % \includesvg[width=0.6\columnwidth]{resources/images/module-dependencies}
    \label{figure:csxfsruntime}
\end{figure}

\section{Kernel Safety}

% How to ensure user submitted CSx compute kernels are safe?

% Potential mechanisms:
% - static verification
% - CSD instrumentation / metadata (report read / write operations and locations)
% - access verifier (runtime verification)

% ---------------------------------------------------------------------------
% ----------------------- end of thesis sub-document ------------------------
% ---------------------------------------------------------------------------